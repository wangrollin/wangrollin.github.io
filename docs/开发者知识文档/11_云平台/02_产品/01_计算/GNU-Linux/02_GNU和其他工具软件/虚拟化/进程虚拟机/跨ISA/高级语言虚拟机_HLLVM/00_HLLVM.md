# 高级语言虚拟机（high-level language virtual machine, HLLVM）

## 概念

按照提供何种级别的ISA，我们把虚拟机分为进程虚拟机和系统虚拟机。对于前者，它致力于提供一种ABI（Application Binary Interface），换言之，是提供了用户级指令和系统调用;对于后者，它致力于提供完整的ISA，包括用户级指令和系统级指令。这两种虚拟机又可以根据它的两侧（guest和host）是否属于同一ISA来进一步细化。从这个分类意义下，高级语言虚拟机被分类在跨ISA的进程虚拟机下，区别是高级语言虚拟机的程序级接口是一种高级的、和其他的进程虚拟机不同的（高级语言语义，一组可以被移植的库）。

这种一致性的ISA正是虚拟指令集架构。它被设计为一种虚拟的、独立于具体的实现的指令集架构。一致性的“操作系统接口”，或言一致性的系统调用，被设计为一种高级语言（这是它得名来历）的接口，也就是一组库。

## 解释（interprete） vs 翻译（translation）

一般而言，解释是这样的过程，它先取源指令，对其进行分析，执行所要进行的操作，然后再取下一条指令，如此循环，直到遇到停机或者中断（end of dispatch- EOD）。而翻译则试图分担取指和分析的代价，它将源代码块翻译成目标代码块，并存起来备用。

## 基本解释（Basic Interpretation）

即便从来没有接触过解释器相关技术，我们也会自然想到用一个switch-case来实现一个基本的解释器。基本的解释器遵循一个译码派发（decode-and-dispatch）流程，也就是一个while循环加上一个switch-case结构。

基础之上进行优化

- 间接线索解释（Indirect Threaded Interpretation）
- 直接线索解释(Direct Threaded Interpretation)

## 解释器的优化技术

### 基于栈和基于寄存器的虚拟机

常见的高级语言虚拟机的字节码上的设计有两种，基于寄存器或者基于栈的。

老的一般是 stack based
新的一般是寄存器 based

### 各种编码方式

编码，对于64位平台我们看到代码中主要有4类可选的技术方案：
- nan-boxing
- pun-boxing
- tagged pointer
- tagged union

## 小结

在一个好的解释器设计中，最重要的就是“权衡”。这其中不仅包含一些技术的权衡（例如，基于寄存器还是基于栈，启动时间还是编译质量等），还包括软件管理的一些权衡（开发成本和效率等）。我愿称解释器的编写为一种权衡的艺术。
