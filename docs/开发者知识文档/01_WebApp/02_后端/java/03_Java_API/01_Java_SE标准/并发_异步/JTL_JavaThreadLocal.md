
## Q&A

> 当某一个线程销毁了，存在threadlocal中的数据怎么办，会不会一起内存泄漏？


## 作用

框架 svc1 -> user code -> 框架 svc2

threadLocal tl1，可以放在框架里，禁止外部访问，从而实现svc1和svc2可以访问tl1，但是user code不能访问 tl1，实现了svc1->svc2的传递，没有通过user code 传递

## JTL 设计缺陷

- 可以自由修改
  - 只要能get，就能set，导致很难理清哪些组件以什么顺序更新了共享变量
  - 更常见的场景是一开始set，后面只需要get
- 无限的生命周期，内存泄漏
  - jtl 会一直存在，直到手动去 remove() jtl，如果没有，就是内存泄漏，垃圾回收无法清理
  - 如果使用线程池，上一个任务和下一个任务会同时接触到同一个 jtl
- 继承很贵
  - jtl 会自动传递给子进程，而且使用的是复制的方式，占用大量内存。主要原因是因为是可改的变量，所以不能复用父线程的

